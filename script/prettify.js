var IN_GLOBAL_SCOPE = !0, prettyPrintOne, prettyPrint; window.PR_SHOULD_USE_CONTINUATION = !0, function () { function combinePrefixPatterns(regexs) { function decodeEscape(charsetPart) { var cc0 = charsetPart.charCodeAt(0), c1; return cc0 !== 92 ? cc0 : (c1 = charsetPart.charAt(1), cc0 = escapeCharToCodeUnit[c1], cc0 ? cc0 : "0" <= c1 && c1 <= "7" ? parseInt(charsetPart.substring(1), 8) : c1 === "u" || c1 === "x" ? parseInt(charsetPart.substring(2), 16) : charsetPart.charCodeAt(1)) } function encodeEscape(charCode) { if (charCode < 32) return (charCode < 16 ? "\\x0" : "\\x") + charCode.toString(16); var ch = String.fromCharCode(charCode); return ch === "\\" || ch === "-" || ch === "]" || ch === "^" ? "\\" + ch : ch } function caseFoldCharset(charSet) { var charsetParts = charSet.substring(1, charSet.length - 1).match(new RegExp("\\\\u[0-9A-Fa-f]{4}|\\\\x[0-9A-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\s\\S]|-|[^-\\\\]", "g")), ranges = [], inverse = charsetParts[0] === "^", out = ["["], n, p, start, end, consolidatedRanges, lastRange, i, range; for (inverse && out.push("^"), i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) p = charsetParts[i], /\\[bdsw]/i.test(p) ? out.push(p) : (start = decodeEscape(p), i + 2 < n && "-" === charsetParts[i + 1] ? (end = decodeEscape(charsetParts[i + 2]), i += 2) : end = start, ranges.push([start, end]), end < 65 || start > 122 || (end < 65 || start > 90 || ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]), end < 97 || start > 122 || ranges.push([Math.max(97, start) & -33, Math.min(end, 122) & -33]))); for (ranges.sort(function (a, b) { return a[0] - b[0] || b[1] - a[1] }), consolidatedRanges = [], lastRange = [], i = 0; i < ranges.length; ++i) range = ranges[i], range[0] <= lastRange[1] + 1 ? lastRange[1] = Math.max(lastRange[1], range[1]) : consolidatedRanges.push(lastRange = range); for (i = 0; i < consolidatedRanges.length; ++i) range = consolidatedRanges[i], out.push(encodeEscape(range[0])), range[1] > range[0] && (range[1] + 1 > range[0] && out.push("-"), out.push(encodeEscape(range[1]))); return out.push("]"), out.join("") } function allowAnywhereFoldCaseAndRenumberGroups(regex) { for (var decimalValue, p, ch0, parts = regex.source.match(new RegExp("(?:\\[(?:[^\\x5C\\x5D]|\\\\[\\s\\S])*\\]|\\\\u[A-Fa-f0-9]{4}|\\\\x[A-Fa-f0-9]{2}|\\\\[0-9]+|\\\\[^ux0-9]|\\(\\?[:!=]|[\\(\\)\\^]|[^\\x5B\\x5C\\(\\)\\^]+)", "g")), n = parts.length, capturedGroups = [], i = 0, groupIndex = 0; i < n; ++i) p = parts[i], p === "(" ? ++groupIndex : "\\" === p.charAt(0) && (decimalValue = +p.substring(1), decimalValue && (decimalValue <= groupIndex ? capturedGroups[decimalValue] = -1 : parts[i] = encodeEscape(decimalValue))); for (i = 1; i < capturedGroups.length; ++i) -1 === capturedGroups[i] && (capturedGroups[i] = ++capturedGroupIndex); for (i = 0, groupIndex = 0; i < n; ++i) p = parts[i], p === "(" ? (++groupIndex, capturedGroups[groupIndex] || (parts[i] = "(?:")) : "\\" === p.charAt(0) && (decimalValue = +p.substring(1), decimalValue && decimalValue <= groupIndex && (parts[i] = "\\" + capturedGroups[decimalValue])); for (i = 0; i < n; ++i) "^" === parts[i] && "^" !== parts[i + 1] && (parts[i] = ""); if (regex.ignoreCase && needToFoldCase) for (i = 0; i < n; ++i) p = parts[i], ch0 = p.charAt(0), p.length >= 2 && ch0 === "[" ? parts[i] = caseFoldCharset(p) : ch0 !== "\\" && (parts[i] = p.replace(/[a-zA-Z]/g, function (ch) { var cc = ch.charCodeAt(0); return "[" + String.fromCharCode(cc & -33, cc | 32) + "]" })); return parts.join("") } for (var escapeCharToCodeUnit, rewritten, regex, capturedGroupIndex = 0, needToFoldCase = !1, ignoreCase = !1, i = 0, n = regexs.length; i < n; ++i) if (regex = regexs[i], regex.ignoreCase) ignoreCase = !0; else if (/[a-z]/i.test(regex.source.replace(/\\u[0-9a-f]{4}|\\x[0-9a-f]{2}|\\[^ux]/gi, ""))) { needToFoldCase = !0; ignoreCase = !1; break } for (escapeCharToCodeUnit = { b: 8, t: 9, n: 10, v: 11, f: 12, r: 13 }, rewritten = [], i = 0, n = regexs.length; i < n; ++i) { if (regex = regexs[i], regex.global || regex.multiline) throw new Error("" + regex); rewritten.push("(?:" + allowAnywhereFoldCaseAndRenumberGroups(regex) + ")") } return new RegExp(rewritten.join("|"), ignoreCase ? "gi" : "g") } function extractSourceSpans(node, isPreformatted) { function walk(node) { var type = node.nodeType, child, nodeName, text; if (type == 1) { if (nocode.test(node.className)) return; for (child = node.firstChild; child; child = child.nextSibling) walk(child); nodeName = node.nodeName.toLowerCase(); ("br" === nodeName || "li" === nodeName) && (chunks[k] = "\n", spans[k << 1] = length++, spans[k++ << 1 | 1] = node) } else (type == 3 || type == 4) && (text = node.nodeValue, text.length && (text = isPreformatted ? text.replace(/\r\n?/g, "\n") : text.replace(/[ \t\r\n]+/g, " "), chunks[k] = text, spans[k << 1] = length, length += text.length, spans[k++ << 1 | 1] = node)) } var nocode = /(?:^|\s)nocode(?:\s|$)/, chunks = [], length = 0, spans = [], k = 0; return walk(node), { sourceCode: chunks.join("").replace(/\n$/, ""), spans: spans } } function appendDecorations(basePos, sourceCode, langHandler, out) { if (sourceCode) { var job = { sourceCode: sourceCode, basePos: basePos }; langHandler(job); out.push.apply(out, job.decorations) } } function childContentWrapper(element) { for (var type, wrapper = undefined, c = element.firstChild; c; c = c.nextSibling) type = c.nodeType, wrapper = type === 1 ? wrapper ? element : c : type === 3 ? notWs.test(c.nodeValue) ? element : wrapper : wrapper; return wrapper === element ? undefined : wrapper } function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) { var shortcuts = {}, tokenizer, nPatterns, decorate; return function () { for (var patternParts, shortcutChars, c, regex, k, allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns), allRegexs = [], regexKeys = {}, i = 0, n = allPatterns.length; i < n; ++i) { if (patternParts = allPatterns[i], shortcutChars = patternParts[3], shortcutChars) for (c = shortcutChars.length; --c >= 0;) shortcuts[shortcutChars.charAt(c)] = patternParts; regex = patternParts[1]; k = "" + regex; regexKeys.hasOwnProperty(k) || (allRegexs.push(regex), regexKeys[k] = null) } allRegexs.push(/[\0-\uffff]/); tokenizer = combinePrefixPatterns(allRegexs) }(), nPatterns = fallthroughStylePatterns.length, decorate = function (job) { for (var patternParts, i, tokenStart, lang, sourceCode = job.sourceCode, basePos = job.basePos, decorations = [basePos, PR_PLAIN], pos = 0, tokens = sourceCode.match(tokenizer) || [], styleCache = {}, ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) { var token = tokens[ti], style = styleCache[token], match = void 0, isEmbedded; if (typeof style == "string") isEmbedded = !1; else { if (patternParts = shortcuts[token.charAt(0)], patternParts) match = token.match(patternParts[1]), style = patternParts[0]; else { for (i = 0; i < nPatterns; ++i) if (patternParts = fallthroughStylePatterns[i], match = token.match(patternParts[1]), match) { style = patternParts[0]; break } match || (style = PR_PLAIN) } isEmbedded = style.length >= 5 && "lang-" === style.substring(0, 5); !isEmbedded || match && typeof match[1] == "string" || (isEmbedded = !1, style = PR_SOURCE); isEmbedded || (styleCache[token] = style) } if (tokenStart = pos, pos += token.length, isEmbedded) { var embeddedSource = match[1], embeddedSourceStart = token.indexOf(embeddedSource), embeddedSourceEnd = embeddedSourceStart + embeddedSource.length; match[2] && (embeddedSourceEnd = token.length - match[2].length, embeddedSourceStart = embeddedSourceEnd - embeddedSource.length); lang = style.substring(5); appendDecorations(basePos + tokenStart, token.substring(0, embeddedSourceStart), decorate, decorations); appendDecorations(basePos + tokenStart + embeddedSourceStart, embeddedSource, langHandlerForExtension(lang, embeddedSource), decorations); appendDecorations(basePos + tokenStart + embeddedSourceEnd, token.substring(embeddedSourceEnd), decorate, decorations) } else decorations.push(basePos + tokenStart, style) } job.decorations = decorations }, decorate } function sourceDecorator(options) { var shortcutStylePatterns = [], fallthroughStylePatterns = [], hc, regexLiterals, types, keywords, punctuation; if (options.tripleQuotedStrings ? shortcutStylePatterns.push([PR_STRING, /^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/, null, "'\""]) : options.multiLineStrings ? shortcutStylePatterns.push([PR_STRING, /^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/, null, "'\"`"]) : shortcutStylePatterns.push([PR_STRING, /^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/, null, "\"'"]), options.verbatimStrings && fallthroughStylePatterns.push([PR_STRING, /^@\"(?:[^\"]|\"\")*(?:\"|$)/, null]), hc = options.hashComments, hc && (options.cStyleComments ? (hc > 1 ? shortcutStylePatterns.push([PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, "#"]) : shortcutStylePatterns.push([PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\r\n]*)/, null, "#"]), fallthroughStylePatterns.push([PR_STRING, /^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/, null])) : shortcutStylePatterns.push([PR_COMMENT, /^#[^\r\n]*/, null, "#"])), options.cStyleComments && (fallthroughStylePatterns.push([PR_COMMENT, /^\/\/[^\r\n]*/, null]), fallthroughStylePatterns.push([PR_COMMENT, /^\/\*[\s\S]*?(?:\*\/|$)/, null])), regexLiterals = options.regexLiterals, regexLiterals) { var regexExcls = regexLiterals > 1 ? "" : "\n\r", regexAny = regexExcls ? "." : "[\\S\\s]", REGEX_LITERAL = "/(?=[^/*" + regexExcls + "])(?:[^/\\x5B\\x5C" + regexExcls + "]|\\x5C" + regexAny + "|\\x5B(?:[^\\x5C\\x5D" + regexExcls + "]|\\x5C" + regexAny + ")*(?:\\x5D|$))+/"; fallthroughStylePatterns.push(["lang-regex", RegExp("^" + REGEXP_PRECEDER_PATTERN + "(" + REGEX_LITERAL + ")")]) } return types = options.types, types && fallthroughStylePatterns.push([PR_TYPE, types]), keywords = ("" + options.keywords).replace(/^ | $/g, ""), keywords.length && fallthroughStylePatterns.push([PR_KEYWORD, new RegExp("^(?:" + keywords.replace(/[\s,]+/g, "|") + ")\\b"), null]), shortcutStylePatterns.push([PR_PLAIN, /^\s+/, null, " \r\n\tÂ "]), punctuation = "^.[^\\s\\w.$@'\"`/\\\\]*", options.regexLiterals && (punctuation += "(?!s*/)"), fallthroughStylePatterns.push([PR_LITERAL, /^@[a-z_$][a-z_$@0-9]*/i, null], [PR_TYPE, /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\w+_t\b)/, null], [PR_PLAIN, /^[a-z_$][a-z_$@0-9]*/i, null], [PR_LITERAL, new RegExp("^(?:0x[a-f0-9]+|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)(?:e[+\\-]?\\d+)?)[a-z]*", "i"), null, "0123456789"], [PR_PLAIN, /^\\[\s\S]?/, null], [PR_PUNCTUATION, new RegExp(punctuation), null]), createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) } function numberLines(node, opt_startLineNum, isPreformatted) { function walk(node) { var type = node.nodeType, child, text, match, firstLine, tail, parent; if (type != 1 || nocode.test(node.className)) (type == 3 || type == 4) && isPreformatted && (text = node.nodeValue, match = text.match(lineBreak), match && (firstLine = text.substring(0, match.index), node.nodeValue = firstLine, tail = text.substring(match.index + match[0].length), tail && (parent = node.parentNode, parent.insertBefore(document.createTextNode(tail), node.nextSibling)), breakAfter(node), firstLine || node.parentNode.removeChild(node))); else if ("br" === node.nodeName) breakAfter(node), node.parentNode && node.parentNode.removeChild(node); else for (child = node.firstChild; child; child = child.nextSibling) walk(child) } function breakAfter(lineEndNode) { function breakLeftOf(limit, copy) { var rightSide = copy ? limit.cloneNode(!1) : limit, parent = limit.parentNode, parentClone, next, sibling; if (parent) for (parentClone = breakLeftOf(parent, 1), next = limit.nextSibling, parentClone.appendChild(rightSide), sibling = next; sibling; sibling = next) next = sibling.nextSibling, parentClone.appendChild(sibling); return rightSide } for (var copiedListItem, parent; !lineEndNode.nextSibling;) if (lineEndNode = lineEndNode.parentNode, !lineEndNode) return; for (copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0) ; (parent = copiedListItem.parentNode) && parent.nodeType === 1;) copiedListItem = parent; listItems.push(copiedListItem) } for (var nocode = /(?:^|\s)nocode(?:\s|$)/, lineBreak = /\r\n?|\n/, document = node.ownerDocument, li = document.createElement("li"), listItems, ol, offset, i, n; node.firstChild;) li.appendChild(node.firstChild); for (listItems = [li], i = 0; i < listItems.length; ++i) walk(listItems[i]); for (opt_startLineNum === (opt_startLineNum | 0) && listItems[0].setAttribute("value", opt_startLineNum), ol = document.createElement("ol"), ol.className = "linenums", offset = Math.max(0, opt_startLineNum - 1 | 0) || 0, i = 0, n = listItems.length; i < n; ++i) li = listItems[i], li.className = "L" + (i + offset) % 10, li.firstChild || li.appendChild(document.createTextNode("Â ")), ol.appendChild(li); node.appendChild(ol) } function recombineTagsAndDecorations(job) { var isIE8OrEarlier = /\bMSIE\s(\d+)/.exec(navigator.userAgent), decPos, i, sourceNode, oldDisplay, decoration, document, span, parentNode; isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8; var newlineRe = /\n/g, source = job.sourceCode, sourceLength = source.length, sourceIndex = 0, spans = job.spans, nSpans = spans.length, spanIndex = 0, decorations = job.decorations, nDecorations = decorations.length, decorationIndex = 0; for (decorations[nDecorations] = sourceLength, i = decPos = 0; i < nDecorations;) decorations[i] !== decorations[i + 2] ? (decorations[decPos++] = decorations[i++], decorations[decPos++] = decorations[i++]) : i += 2; for (nDecorations = decPos, i = decPos = 0; i < nDecorations;) { for (var startPos = decorations[i], startDec = decorations[i + 1], end = i + 2; end + 2 <= nDecorations && decorations[end + 1] === startDec;) end += 2; decorations[decPos++] = startPos; decorations[decPos++] = startDec; i = end } nDecorations = decorations.length = decPos; sourceNode = job.sourceNode; sourceNode && (oldDisplay = sourceNode.style.display, sourceNode.style.display = "none"); try { for (decoration = null; spanIndex < nSpans;) { var spanStart = spans[spanIndex], spanEnd = spans[spanIndex + 2] || sourceLength, decEnd = decorations[decorationIndex + 2] || sourceLength, end = Math.min(spanEnd, decEnd), textNode = spans[spanIndex + 1], styledText; textNode.nodeType !== 1 && (styledText = source.substring(sourceIndex, end)) && (isIE8OrEarlier && (styledText = styledText.replace(newlineRe, "\r")), textNode.nodeValue = styledText, document = textNode.ownerDocument, span = document.createElement("span"), span.className = decorations[decorationIndex + 1], parentNode = textNode.parentNode, parentNode.replaceChild(span, textNode), span.appendChild(textNode), sourceIndex < spanEnd && (spans[spanIndex + 1] = textNode = document.createTextNode(source.substring(end, spanEnd)), parentNode.insertBefore(textNode, span.nextSibling))); sourceIndex = end; sourceIndex >= spanEnd && (spanIndex += 2); sourceIndex >= decEnd && (decorationIndex += 2) } } finally { sourceNode && (sourceNode.style.display = oldDisplay) } } function registerLangHandler(handler, fileExtensions) { for (var ext, i = fileExtensions.length; --i >= 0;) ext = fileExtensions[i], langHandlerRegistry.hasOwnProperty(ext) ? win.console && console.warn("cannot override language handler %s", ext) : langHandlerRegistry[ext] = handler } function langHandlerForExtension(extension, source) { return extension && langHandlerRegistry.hasOwnProperty(extension) || (extension = /^\s*</.test(source) ? "default-markup" : "default-code", extension = /^\s*@/.test(source) ? "default-markup" : extension), langHandlerRegistry[extension] } function applyDecorator(job) { var opt_langExtension = job.langExtension, sourceAndSpans, source; try { sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre); source = sourceAndSpans.sourceCode; job.sourceCode = source; job.spans = sourceAndSpans.spans; job.basePos = 0; langHandlerForExtension(opt_langExtension, source)(job); recombineTagsAndDecorations(job) } catch (e) { win.console && console.log(e && e.stack || e) } } function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) { var container = document.createElement("div"), job; return container.innerHTML = "<pre>" + sourceCodeHtml + "<\/pre>", container = container.firstChild, opt_numberLines && numberLines(container, opt_numberLines, !0), job = { langExtension: opt_langExtension, numberLines: opt_numberLines, sourceNode: container, pre: 1 }, applyDecorator(job), container.innerHTML } function $prettyPrint(opt_whenDone, opt_root) { function byTagName(tn) { return root.getElementsByTagName(tn) } function doWork() { for (var endTime = win.PR_SHOULD_USE_CONTINUATION ? clock.now() + 250 : Infinity, cs, attrs, preceder, nt, value, className, nested, p, tn, langExtension, wrapper, preformatted, lineNums; k < elements.length && clock.now() < endTime; k++) { for (cs = elements[k], attrs = EMPTY, preceder = cs; preceder = preceder.previousSibling;) { if (nt = preceder.nodeType, value = (nt === 7 || nt === 8) && preceder.nodeValue, value ? !/^\??prettify\b/.test(value) : nt !== 3 || /\S/.test(preceder.nodeValue)) break; if (value) { attrs = {}; value.replace(/\b(\w+)=([\w:.%+-]+)/g, function (_, name, value) { attrs[name] = value }); break } } if (className = cs.className, (attrs !== EMPTY || prettyPrintRe.test(className)) && !prettyPrintedRe.test(className)) { for (nested = !1, p = cs.parentNode; p; p = p.parentNode) if (tn = p.tagName, preCodeXmpRe.test(tn) && p.className && prettyPrintRe.test(p.className)) { nested = !0; break } if (!nested) { if (cs.className += " prettyprinted", langExtension = attrs.lang, langExtension || (langExtension = className.match(langExtensionRe), !langExtension && (wrapper = childContentWrapper(cs)) && codeRe.test(wrapper.tagName) && (langExtension = wrapper.className.match(langExtensionRe)), langExtension && (langExtension = langExtension[1])), preformattedTagNameRe.test(cs.tagName)) preformatted = 1; else { var currentStyle = cs.currentStyle, defaultView = doc.defaultView, whitespace = currentStyle ? currentStyle.whiteSpace : defaultView && defaultView.getComputedStyle ? defaultView.getComputedStyle(cs, null).getPropertyValue("white-space") : 0; preformatted = whitespace && "pre" === whitespace.substring(0, 3) } lineNums = attrs.linenums; (lineNums = lineNums === "true" || +lineNums) || (lineNums = className.match(/\blinenums\b(?::(\d+))?/), lineNums = lineNums ? lineNums[1] && lineNums[1].length ? +lineNums[1] : !0 : !1); lineNums && numberLines(cs, lineNums, preformatted); prettyPrintingJob = { langExtension: langExtension, sourceNode: cs, numberLines: lineNums, pre: preformatted }; applyDecorator(prettyPrintingJob) } } } k < elements.length ? setTimeout(doWork, 250) : "function" == typeof opt_whenDone && opt_whenDone() } for (var j, n, clock, root = opt_root || document.body, doc = root.ownerDocument || document, codeSegments = [byTagName("pre"), byTagName("code"), byTagName("xmp"), byTagName("samp")], elements = [], i = 0; i < codeSegments.length; ++i) for (j = 0, n = codeSegments[i].length; j < n; ++j) elements.push(codeSegments[i][j]); codeSegments = null; clock = Date; clock.now || (clock = { now: function () { return +new Date } }); var k = 0, prettyPrintingJob, langExtensionRe = /\blang(?:uage)?-([\w.]+)(?!\S)/, prettyPrintRe = /\bprettyprint\b/, prettyPrintedRe = /\bprettyprinted\b/, preformattedTagNameRe = /pre|xmp/i, codeRe = /^code$/i, preCodeXmpRe = /^(?:pre|code|xmp)$/i, EMPTY = {}; doWork() } var win = window, FLOW_CONTROL_KEYWORDS = ["break,continue,do,else,for,if,return,while"], C_KEYWORDS = [FLOW_CONTROL_KEYWORDS, "auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"], COMMON_KEYWORDS = [C_KEYWORDS, "catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"], CPP_KEYWORDS = [COMMON_KEYWORDS, "alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"], JAVA_KEYWORDS = [COMMON_KEYWORDS, "abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"], CSHARP_KEYWORDS = [JAVA_KEYWORDS, "as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,internal,into,is,let,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"], JSCRIPT_KEYWORDS = [COMMON_KEYWORDS, "debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"], PERL_KEYWORDS = "caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END", PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, "and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"], RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, "alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"], RUST_KEYWORDS = [FLOW_CONTROL_KEYWORDS, "as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"], SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, "case,done,elif,esac,eval,fi,function,in,local,set,then,until"], ALL_KEYWORDS = [CPP_KEYWORDS, CSHARP_KEYWORDS, JSCRIPT_KEYWORDS, PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS], C_TYPES = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/, PR_STRING = "str", PR_KEYWORD = "kwd", PR_COMMENT = "com", PR_TYPE = "typ", PR_LITERAL = "lit", PR_PUNCTUATION = "pun", PR_PLAIN = "pln", PR_TAG = "tag", PR_DECLARATION = "dec", PR_SOURCE = "src", PR_ATTRIB_NAME = "atn", PR_ATTRIB_VALUE = "atv", REGEXP_PRECEDER_PATTERN = "(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*", notWs = /\S/, decorateSource = sourceDecorator({ keywords: ALL_KEYWORDS, hashComments: !0, cStyleComments: !0, multiLineStrings: !0, regexLiterals: !0 }), langHandlerRegistry = {}, PR; registerLangHandler(decorateSource, ["default-code"]); registerLangHandler(createSimpleLexer([], [[PR_PLAIN, /^[^<?]+/], [PR_DECLARATION, /^<!\w[^>]*(?:>|$)/], [PR_COMMENT, /^<\!--[\s\S]*?(?:-\->|$)/], ["lang-", /^<\?([\s\S]+?)(?:\?>|$)/], ["lang-", /^<%([\s\S]+?)(?:%>|$)/], [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/], ["lang-", /^<xmp\b[^>]*>([\s\S]+?)<\/xmp\b[^>]*>/i], ["lang-js", /^<script\b[^>]*>([\s\S]*?)(<\/script\b[^>]*>)/i], ["lang-css", /^<style\b[^>]*>([\s\S]*?)(<\/style\b[^>]*>)/i], ["lang-in.tag", /^(<\/?[a-z][^<>]*>)/i]]), ["default-markup", "htm", "html", "mxml", "xhtml", "xml", "xsl"]); registerLangHandler(createSimpleLexer([[PR_PLAIN, /^[\s]+/, null, " \t\r\n"], [PR_ATTRIB_VALUE, /^(?:\"[^\"]*\"?|\'[^\']*\'?)/, null, "\"'"]], [[PR_TAG, /^^<\/?[a-z](?:[\w.:-]*\w)?|\/?>$/i], [PR_ATTRIB_NAME, /^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i], ["lang-uq.val", /^=\s*([^>\'\"\s]*(?:[^>\'\"\s\/]|\/(?=\s)))/], [PR_PUNCTUATION, /^[=<>\/]+/], ["lang-js", /^on\w+\s*=\s*\"([^\"]+)\"/i], ["lang-js", /^on\w+\s*=\s*\'([^\']+)\'/i], ["lang-js", /^on\w+\s*=\s*([^\"\'>\s]+)/i], ["lang-css", /^style\s*=\s*\"([^\"]+)\"/i], ["lang-css", /^style\s*=\s*\'([^\']+)\'/i], ["lang-css", /^style\s*=\s*([^\"\'>\s]+)/i]]), ["in.tag"]); registerLangHandler(createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\s\S]+/]]), ["uq.val"]); registerLangHandler(sourceDecorator({ keywords: CPP_KEYWORDS, hashComments: !0, cStyleComments: !0, types: C_TYPES }), ["c", "cc", "cpp", "cxx", "cyc", "m"]); registerLangHandler(sourceDecorator({ keywords: "null,true,false" }), ["json"]); registerLangHandler(sourceDecorator({ keywords: CSHARP_KEYWORDS, hashComments: !0, cStyleComments: !0, verbatimStrings: !0, types: C_TYPES }), ["cs"]); registerLangHandler(sourceDecorator({ keywords: JAVA_KEYWORDS, cStyleComments: !0 }), ["java"]); registerLangHandler(sourceDecorator({ keywords: SH_KEYWORDS, hashComments: !0, multiLineStrings: !0 }), ["bash", "bsh", "csh", "sh"]); registerLangHandler(sourceDecorator({ keywords: PYTHON_KEYWORDS, hashComments: !0, multiLineStrings: !0, tripleQuotedStrings: !0 }), ["cv", "py", "python"]); registerLangHandler(sourceDecorator({ keywords: PERL_KEYWORDS, hashComments: !0, multiLineStrings: !0, regexLiterals: 2 }), ["perl", "pl", "pm"]); registerLangHandler(sourceDecorator({ keywords: RUBY_KEYWORDS, hashComments: !0, multiLineStrings: !0, regexLiterals: !0 }), ["rb", "ruby"]); registerLangHandler(sourceDecorator({ keywords: JSCRIPT_KEYWORDS, cStyleComments: !0, regexLiterals: !0 }), ["javascript", "js"]); registerLangHandler(sourceDecorator({ keywords: "all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes", hashComments: 3, cStyleComments: !0, multilineStrings: !0, tripleQuotedStrings: !0, regexLiterals: !0 }), ["coffee"]); registerLangHandler(sourceDecorator({ keywords: RUST_KEYWORDS, cStyleComments: !0, multilineStrings: !0 }), ["rc", "rs", "rust"]); registerLangHandler(createSimpleLexer([], [[PR_STRING, /^[\s\S]+/]]), ["regex"]); PR = win.PR = { createSimpleLexer: createSimpleLexer, registerLangHandler: registerLangHandler, sourceDecorator: sourceDecorator, PR_ATTRIB_NAME: PR_ATTRIB_NAME, PR_ATTRIB_VALUE: PR_ATTRIB_VALUE, PR_COMMENT: PR_COMMENT, PR_DECLARATION: PR_DECLARATION, PR_KEYWORD: PR_KEYWORD, PR_LITERAL: PR_LITERAL, PR_NOCODE: "nocode", PR_PLAIN: PR_PLAIN, PR_PUNCTUATION: PR_PUNCTUATION, PR_SOURCE: PR_SOURCE, PR_STRING: PR_STRING, PR_TAG: PR_TAG, PR_TYPE: PR_TYPE, prettyPrintOne: IN_GLOBAL_SCOPE ? win.prettyPrintOne = $prettyPrintOne : prettyPrintOne = $prettyPrintOne, prettyPrint: prettyPrint = IN_GLOBAL_SCOPE ? win.prettyPrint = $prettyPrint : prettyPrint = $prettyPrint }; typeof define == "function" && define.amd && define("google-code-prettify", [], function () { return PR }) }(); PR.registerLangHandler(PR.createSimpleLexer([[PR.PR_PLAIN, /^[\t\n\r \xA0\u2028\u2029]+/, null, "\t\n\r Â \u2028\u2029"], [PR.PR_STRING, /^(?:[\"\u201C\u201D](?:[^\"\u201C\u201D]|[\"\u201C\u201D]{2})(?:[\"\u201C\u201D]c|$)|[\"\u201C\u201D](?:[^\"\u201C\u201D]|[\"\u201C\u201D]{2})*(?:[\"\u201C\u201D]|$))/i, null, '"â€œâ€'], [PR.PR_COMMENT, /^[\'\u2018\u2019](?:_(?:\r\n?|[^\r]?)|[^\r\n_\u2028\u2029])*/, null, "'â€˜â€™"]], [[PR.PR_KEYWORD, /^(?:AddHandler|AddressOf|Alias|And|AndAlso|Ansi|As|Assembly|Auto|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|CBool|CByte|CChar|CDate|CDbl|CDec|Char|CInt|Class|CLng|CObj|Const|CShort|CSng|CStr|CType|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else|ElseIf|End|EndIf|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get|GetType|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|Let|Lib|Like|Long|Loop|Me|Mod|Module|MustInherit|MustOverride|MyBase|MyClass|Namespace|New|Next|Not|NotInheritable|NotOverridable|Object|On|Option|Optional|Or|OrElse|Overloads|Overridable|Overrides|ParamArray|Preserve|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|Select|Set|Shadows|Shared|Short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TypeOf|Unicode|Until|Variant|Wend|When|While|With|WithEvents|WriteOnly|Xor|EndIf|GoSub|Let|Variant|Wend)\b/i, null], [PR.PR_COMMENT, /^REM\b[^\r\n\u2028\u2029]*/i], [PR.PR_LITERAL, /^(?:True\b|False\b|Nothing\b|\d+(?:E[+\-]?\d+[FRD]?|[FRDSIL])?|(?:&H[0-9A-F]+|&O[0-7]+)[SIL]?|\d*\.\d+(?:E[+\-]?\d+)?[FRD]?|#\s+(?:\d+[\-\/]\d+[\-\/]\d+(?:\s+\d+:\d+(?::\d+)?(\s*(?:AM|PM))?)?|\d+:\d+(?::\d+)?(\s*(?:AM|PM))?)\s+#)/i], [PR.PR_PLAIN, /^(?:(?:[a-z]|_\w)\w*(?:\[[%&@!#]+\])?|\[(?:[a-z]|_\w)\w*\])/i], [PR.PR_PUNCTUATION, /^[^\w\t\n\r \"\'\[\]\xA0\u2018\u2019\u201C\u201D\u2028\u2029]+/], [PR.PR_PUNCTUATION, /^(?:\[|\])/]]), ["vb", "vbs"]); PR.registerLangHandler(PR.createSimpleLexer([[PR.PR_PLAIN, /^[ \t\r\n\f]+/, null, " \t\r\n\f"]], [[PR.PR_STRING, /^\"(?:[^\n\r\f\\\"]|\\(?:\r\n?|\n|\f)|\\[\s\S])*\"/, null], [PR.PR_STRING, /^\'(?:[^\n\r\f\\\']|\\(?:\r\n?|\n|\f)|\\[\s\S])*\'/, null], ["lang-css-str", /^url\(([^\)\"\']+)\)/i], [PR.PR_KEYWORD, /^(?:url|rgb|\!important|@import|@page|@media|@charset|inherit)(?=[^\-\w]|$)/i, null], ["lang-css-kw", /^(-?(?:[_a-z]|(?:\\[0-9a-f]+ ?))(?:[_a-z0-9\-]|\\(?:\\[0-9a-f]+ ?))*)\s*:/i], [PR.PR_COMMENT, /^\/\*[^*]*\*+(?:[^\/*][^*]*\*+)*\//], [PR.PR_COMMENT, /^(?:<!--|-->)/], [PR.PR_LITERAL, /^(?:\d+|\d*\.\d+)(?:%|[a-z]+)?/i], [PR.PR_LITERAL, /^#(?:[0-9a-f]{3}){1,2}\b/i], [PR.PR_PLAIN, /^-?(?:[_a-z]|(?:\\[\da-f]+ ?))(?:[_a-z\d\-]|\\(?:\\[\da-f]+ ?))*/i], [PR.PR_PUNCTUATION, /^[^\s\w\'\"]+/]]), ["css"]); PR.registerLangHandler(PR.createSimpleLexer([], [[PR.PR_KEYWORD, /^-?(?:[_a-z]|(?:\\[\da-f]+ ?))(?:[_a-z\d\-]|\\(?:\\[\da-f]+ ?))*/i]]), ["css-kw"]); PR.registerLangHandler(PR.createSimpleLexer([], [[PR.PR_STRING, /^[^\)\"\']+/]]), ["css-str"]); PR.registerLangHandler(PR.createSimpleLexer([[PR.PR_PLAIN, /^[\t\n\r \xA0]+/, null, "\t\n\r Â "], [PR.PR_STRING, /^(?:"(?:[^\"\\]|\\.)*"|'(?:[^\'\\]|\\.)*')/, null, "\"'"]], [[PR.PR_COMMENT, /^(?:--[^\r\n]*|\/\*[\s\S]*?(?:\*\/|$))/], [PR.PR_KEYWORD, /^(?:ADD|ALL|ALTER|AND|ANY|APPLY|AS|ASC|AUTHORIZATION|BACKUP|BEGIN|BETWEEN|BREAK|BROWSE|BULK|BY|CASCADE|CASE|CHECK|CHECKPOINT|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMN|COMMIT|COMPUTE|CONNECT|CONSTRAINT|CONTAINS|CONTAINSTABLE|CONTINUE|CONVERT|CREATE|CROSS|CURRENT|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|CURRENT_USER|CURSOR|DATABASE|DBCC|DEALLOCATE|DECLARE|DEFAULT|DELETE|DENY|DESC|DISK|DISTINCT|DISTRIBUTED|DOUBLE|DROP|DUMMY|DUMP|ELSE|END|ERRLVL|ESCAPE|EXCEPT|EXEC|EXECUTE|EXISTS|EXIT|FETCH|FILE|FILLFACTOR|FOLLOWING|FOR|FOREIGN|FREETEXT|FREETEXTTABLE|FROM|FULL|FUNCTION|GOTO|GRANT|GROUP|HAVING|HOLDLOCK|IDENTITY|IDENTITYCOL|IDENTITY_INSERT|IF|IN|INDEX|INNER|INSERT|INTERSECT|INTO|IS|JOIN|KEY|KILL|LEFT|LIKE|LINENO|LOAD|MATCH|MATCHED|MERGE|NATURAL|NATIONAL|NOCHECK|NONCLUSTERED|NOCYCLE|NOT|NULL|NULLIF|OF|OFF|OFFSETS|ON|OPEN|OPENDATASOURCE|OPENQUERY|OPENROWSET|OPENXML|OPTION|OR|ORDER|OUTER|OVER|PARTITION|PERCENT|PIVOT|PLAN|PRECEDING|PRECISION|PRIMARY|PRINT|PROC|PROCEDURE|PUBLIC|RAISERROR|READ|READTEXT|RECONFIGURE|REFERENCES|REPLICATION|RESTORE|RESTRICT|RETURN|REVOKE|RIGHT|ROLLBACK|ROWCOUNT|ROWGUIDCOL|ROWS?|RULE|SAVE|SCHEMA|SELECT|SESSION_USER|SET|SETUSER|SHUTDOWN|SOME|START|STATISTICS|SYSTEM_USER|TABLE|TEXTSIZE|THEN|TO|TOP|TRAN|TRANSACTION|TRIGGER|TRUNCATE|TSEQUAL|UNBOUNDED|UNION|UNIQUE|UNPIVOT|UPDATE|UPDATETEXT|USE|USER|USING|VALUES|VARYING|VIEW|WAITFOR|WHEN|WHERE|WHILE|WITH|WITHIN|WRITETEXT|XML)(?=[^\w-]|$)/i, null], [PR.PR_LITERAL, /^[+-]?(?:0x[\da-f]+|(?:(?:\.\d+|\d+(?:\.\d*)?)(?:e[+\-]?\d+)?))/i], [PR.PR_PLAIN, /^[a-z_][\w-]*/i], [PR.PR_PUNCTUATION, /^[^\w\t\n\r \xA0\"\'][^\w\t\n\r \xA0+\-\"\']*/]]), ["sql"])/*from www.asp.net by onlydel */